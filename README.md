# design-mode
记录学习Head First-设计模式过程

![image](https://user-images.githubusercontent.com/67896996/222059425-b43ed8db-a3db-4ca2-ba15-39b9c28de269.png)

前言：<br>
1. 原先我们在v1.0.1版本的需求，基于面向对象准则简单的设计了抽象父类Duck和不同产品的子类（红头鸭、绿头鸭等）。<br>
2. 但在v.1.0.2版本【新增飞行行为】需求的时候，给父类Duck新增fly()方法时，我们发现了许多问题：比如橡皮鸭也会飞？<br>

过程：<br>
为了解决上面问题，我们原先是想着让不会飞的鸭子覆盖父类Duck的fly()方法，但发现需要覆盖的鸭子特别多，意味改动的代码很多；<br>
于是我们打算利用接口，把【飞行行为】、【呱呱叫行为】抽取成接口，这样会飞的鸭子（子类）去实现飞行接口；<br>
但是我们又发现这样做需要改动的代码也很多，并且还有很多重复代码(代码无法复用)，甚至会飞的鸭子中，飞行的行为可能还有多种变化...<br>

分析：<br>
利用继承来提供Duck的行为，有缺点：<br>
1) 比如说运行时的行为不易改变;<br>
2) 改变会牵一发动全身，造成其他鸭子不想要的改变；<br>

思考：<br>
1) 主要问题是因为鸭子的行为在子类里不断地改变，并且让所有的子类都有这些行为是不恰当；<br>
那么要是我们可以“把会变的部分取出来封装起来，以便以后可以轻易地改动或扩充此部分，而不影响不需要变化的其他部分”，不就可以解决问题了吗？<br>
至此，我们就收获到一个设计原则：【找出应用中可能需要变化之处，把它们独立出来，不要和那些不需要变化的代码混在一起】。<br>
2) 前面我们是利用接口将行为抽取成接口，会造成代码无法复用；这是因为我们让鸭子（子类）去实现行为接口，并且飞行的行为可能还有多种变化；<br>
这时候我们会想到一个词”动态“，要是我们可以在”运行时“动态地”改变“鸭子的飞行行为，而具体的飞行类型，我们委托给具体行为实现类去实现。<br>
这就是我们常听见的设计原则：【针对接口编程，而不是针对实现编程】。<br>

疑问：<br>
用一个类代表一个行为，感觉有点奇怪，类不是应该同时具备状态与“行为”吗？<br>
在OO系统中，是这样的，类代表的东西一般都是既有状态（实例变量）又有方法，只是在本例中，碰巧“东西”是个行为。<br>
但是即使是行为，也仍然可以有状态和方法，例如，飞行的行为可以具有实例变量，记录飞行行为的属性（每秒翅膀拍动几下、最大高度和速度等）。<br>

改造：<br>
每个鸭子都有一个FlyBehavior和一个QuackBehavior，好将飞行和呱呱叫委托给它们行为处理。<br>
这也是我们常听见的设计原则：【多用组合，少用继承】。<br>

恭喜你：学会了策略模式！！！<br>
【策略模式】定义了算法族，分别封装起来，让它们之间可以相互替换。<br>
